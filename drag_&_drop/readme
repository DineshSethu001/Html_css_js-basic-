🟦 Code with Explanation
const list = document.querySelector(".sorted-list");


👉 Finds the <ul> element with class sorted-list and stores it in a variable list.

This is the main container holding all the draggable <li> items.

const items = document.querySelectorAll(".item");


👉 Selects all <li> elements with the class item and stores them in items.

items is a NodeList (like an array) of all draggable list items.

items.forEach(item => {


👉 Loops through each list item.

We are going to attach events (dragstart and dragend) to every item.

  item.addEventListener("dragstart", () => {
    item.classList.add("dragging");
  });


👉 When you start dragging an item:

dragstart event triggers.

It adds a CSS class dragging to the item (used for styling, like faded effect).

  item.addEventListener("dragend", () => {
    item.classList.remove("dragging");
  });


👉 When dragging stops (you drop it):

dragend event triggers.

Removes the dragging class, so the item goes back to normal style.

list.addEventListener("dragover", e => {
  e.preventDefault(); // allow drop


👉 When dragging over the <ul> container:

By default, browsers do NOT allow dropping.

e.preventDefault() tells the browser: “Yes, allow dropping here.”

  const draggingItem = document.querySelector(".dragging");


👉 Finds the element that is currently being dragged.

We know it because earlier we added .dragging class on dragstart.

  const afterElement = getDragAfterElement(list, e.clientY);


👉 Calls the helper function getDragAfterElement.

Passes the container (list) and the mouse’s Y position (e.clientY).

This function figures out where to insert the dragged item (above or below another item).

  if (afterElement == null) {
    list.appendChild(draggingItem);
  } else {
    list.insertBefore(draggingItem, afterElement);
  }
});


👉 Two cases:

If there is no element after mouse position → put the dragged item at the end of the list (appendChild).

Otherwise → insert the dragged item just before the found element.

🔹 The Magic Function
function getDragAfterElement(container, y) {


👉 A helper function to calculate which element should come after the dragged one.

container = <ul>

y = mouse position (vertical axis)

  const draggableElements = [...container.querySelectorAll(".item:not(.dragging)")];


👉 Finds all .item elements except the one being dragged.

:not(.dragging) filters out the current moving item.

[...] converts NodeList into a normal array so we can use .reduce().

  return draggableElements.reduce((closest, child) => {


👉 Loops through every non-dragging item (child) and tries to figure out which one is closest to the mouse pointer.

Uses .reduce() to compare all items and return the best match.

    const box = child.getBoundingClientRect();


👉 Gets the position and size of the item (child) on the screen.

Includes top, bottom, height, etc.

    const offset = y - box.top - box.height / 2;


👉 Calculates how far the mouse y is from the center of the item.

If offset < 0 → mouse is above the center.

If offset > 0 → mouse is below the center.

    if (offset < 0 && offset > closest.offset) {
      return { offset: offset, element: child };
    } else {
      return closest;
    }


👉 Finds the closest element above the mouse:

offset < 0 → means mouse is above this item’s center.

offset > closest.offset → ensures it’s the nearest one.

  }, { offset: Number.NEGATIVE_INFINITY }).element;
}


👉 Starts with a “fake” closest value (-∞) and keeps updating.

Finally, returns the .element that is the correct insertion point.
