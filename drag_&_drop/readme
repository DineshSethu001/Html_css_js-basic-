ğŸŸ¦ Code with Explanation
const list = document.querySelector(".sorted-list");


ğŸ‘‰ Finds the <ul> element with class sorted-list and stores it in a variable list.

This is the main container holding all the draggable <li> items.

const items = document.querySelectorAll(".item");


ğŸ‘‰ Selects all <li> elements with the class item and stores them in items.

items is a NodeList (like an array) of all draggable list items.

items.forEach(item => {


ğŸ‘‰ Loops through each list item.

We are going to attach events (dragstart and dragend) to every item.

  item.addEventListener("dragstart", () => {
    item.classList.add("dragging");
  });


ğŸ‘‰ When you start dragging an item:

dragstart event triggers.

It adds a CSS class dragging to the item (used for styling, like faded effect).

  item.addEventListener("dragend", () => {
    item.classList.remove("dragging");
  });


ğŸ‘‰ When dragging stops (you drop it):

dragend event triggers.

Removes the dragging class, so the item goes back to normal style.

list.addEventListener("dragover", e => {
  e.preventDefault(); // allow drop


ğŸ‘‰ When dragging over the <ul> container:

By default, browsers do NOT allow dropping.

e.preventDefault() tells the browser: â€œYes, allow dropping here.â€

  const draggingItem = document.querySelector(".dragging");


ğŸ‘‰ Finds the element that is currently being dragged.

We know it because earlier we added .dragging class on dragstart.

  const afterElement = getDragAfterElement(list, e.clientY);


ğŸ‘‰ Calls the helper function getDragAfterElement.

Passes the container (list) and the mouseâ€™s Y position (e.clientY).

This function figures out where to insert the dragged item (above or below another item).

  if (afterElement == null) {
    list.appendChild(draggingItem);
  } else {
    list.insertBefore(draggingItem, afterElement);
  }
});


ğŸ‘‰ Two cases:

If there is no element after mouse position â†’ put the dragged item at the end of the list (appendChild).

Otherwise â†’ insert the dragged item just before the found element.

ğŸ”¹ The Magic Function
function getDragAfterElement(container, y) {


ğŸ‘‰ A helper function to calculate which element should come after the dragged one.

container = <ul>

y = mouse position (vertical axis)

  const draggableElements = [...container.querySelectorAll(".item:not(.dragging)")];


ğŸ‘‰ Finds all .item elements except the one being dragged.

:not(.dragging) filters out the current moving item.

[...] converts NodeList into a normal array so we can use .reduce().

  return draggableElements.reduce((closest, child) => {


ğŸ‘‰ Loops through every non-dragging item (child) and tries to figure out which one is closest to the mouse pointer.

Uses .reduce() to compare all items and return the best match.

    const box = child.getBoundingClientRect();


ğŸ‘‰ Gets the position and size of the item (child) on the screen.

Includes top, bottom, height, etc.

    const offset = y - box.top - box.height / 2;


ğŸ‘‰ Calculates how far the mouse y is from the center of the item.

If offset < 0 â†’ mouse is above the center.

If offset > 0 â†’ mouse is below the center.

    if (offset < 0 && offset > closest.offset) {
      return { offset: offset, element: child };
    } else {
      return closest;
    }


ğŸ‘‰ Finds the closest element above the mouse:

offset < 0 â†’ means mouse is above this itemâ€™s center.

offset > closest.offset â†’ ensures itâ€™s the nearest one.

  }, { offset: Number.NEGATIVE_INFINITY }).element;
}


ğŸ‘‰ Starts with a â€œfakeâ€ closest value (-âˆ) and keeps updating.

Finally, returns the .element that is the correct insertion point.
